<!DOCTYPE html><html lang="cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础知识点 | Concentration-point</title><meta name="author" content="集中一点"><meta name="copyright" content="集中一点"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="感谢韩顺平老师的网课！韩顺平老师Java基础 基础知识字符串转对应的数据类型，   需要相应的方法Integer.parseIntDouble.parseDouble字符串转字符：取出字符串第一个字符：s.charAt(0) 算术运算符%：  取余的本质在于公式：a%b&#x3D;a-a&#x2F;b*b，因此即使是负数也是可以取余的。注意：当a为浮点型时，有一步要强转成整数进行计算，此时  a%b&#x3D;a-(int)a">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础知识点">
<meta property="og:url" content="http://example.com/2024/12/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="Concentration-point">
<meta property="og:description" content="感谢韩顺平老师的网课！韩顺平老师Java基础 基础知识字符串转对应的数据类型，   需要相应的方法Integer.parseIntDouble.parseDouble字符串转字符：取出字符串第一个字符：s.charAt(0) 算术运算符%：  取余的本质在于公式：a%b&#x3D;a-a&#x2F;b*b，因此即使是负数也是可以取余的。注意：当a为浮点型时，有一步要强转成整数进行计算，此时  a%b&#x3D;a-(int)a">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/img/icon1point.jpg">
<meta property="article:published_time" content="2024-12-08T15:22:12.000Z">
<meta property="article:modified_time" content="2025-08-08T15:27:07.808Z">
<meta property="article:author" content="集中一点">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/icon1point.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java基础知识点",
  "url": "http://example.com/2024/12/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/",
  "image": "http://example.com/img/icon1point.jpg",
  "datePublished": "2024-12-08T15:22:12.000Z",
  "dateModified": "2025-08-08T15:27:07.808Z",
  "author": [
    {
      "@type": "Person",
      "name": "集中一点",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/icon1point.jpg"><link rel="canonical" href="http://example.com/2024/12/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础知识点',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/fonts/fonts.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/icon1point.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/"><span> CodingLife</span></a></div><div class="menus_item"><a class="site-page" href="/"><span> Thinking</span></a></div><div class="menus_item"><a class="site-page" href="/"><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Concentration-point</span></a><a class="nav-page-title" href="/"><span class="site-name">Java基础知识点</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/"><span> CodingLife</span></a></div><div class="menus_item"><a class="site-page" href="/"><span> Thinking</span></a></div><div class="menus_item"><a class="site-page" href="/"><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java基础知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-12-08T15:22:12.000Z" title="Created 2024-12-08 23:22:12">2024-12-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-08-08T15:27:07.808Z" title="Updated 2025-08-08 23:27:07">2025-08-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>感谢韩顺平老师的网课！<br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fh411y7R8/?spm_id_from=333.337.search-card.all.click">韩顺平老师Java基础</a></p>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>字符串转对应的数据类型，   需要相应的方法<br><code>Integer.parseInt</code><br><code>Double.parseDouble</code><br>字符串转字符：取出字符串第一个字符：<code>s.charAt(0)</code></p>
<p><strong>算术运算符</strong><br>%：  取余的本质在于公式：<code>a%b=a-a/b*b</code>，因此即使是负数也是可以取余的。注意：当a为浮点型时，有一步要强转成整数进行计算，此时  <code>a%b=a-(int)a/b*b</code></p>
<ul>
<li>&amp;&amp;：短路与</li>
<li>当第一个条件为假时，&amp;&amp;不会进行下一条件的判断，&amp;会把下一条件判断完</li>
<li>因此常用&amp;&amp;</li>
</ul>
<p><strong>swicth:</strong></p>
<ol>
<li>switch(num)，这个变量num的类型仅限于byte,short,int,rnum,char,string六种数据类型</li>
<li>写在case后的<strong>常量</strong>类型，要与num类型相同，或者，可以向num的数据类型兼容</li>
<li>若当前case满足条件且未设置break，则会忽略下面的case，穿透执行里面的语句，直至遇到下一个break。利用这个性质，可以设置多个case，满足其中一个case时，输出他们共同的输出语句。</li>
</ol>
<p>可变参数有以下需要注意的点：</p>
<ol>
<li>可变参数可以和普通参数共同作为函数的形参，但可变参数必须放在末尾</li>
<li>在一个函数的形参中，可变参数只能有一个</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型... 数据名</span><br><span class="line">例：<span class="type">int</span>... num</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>(实参值)         <span class="comment">//因为构造器没有函数名，因此也就没有.</span></span><br><span class="line">例：</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//this访问构造器，只能在一个构造器内访问另一个构造器，且必须写在开头位置</span></span><br><span class="line">	<span class="built_in">this</span>(<span class="string">&quot;syx&quot;</span>,<span class="number">23</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;这是person()构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;这是person(String name,int age)构造器&quot;</span>);</span><br><span class="line">	<span class="built_in">this</span>.name=name;   <span class="comment">//this指向当前创建的对象</span></span><br><span class="line">	<span class="built_in">this</span>.age=age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：this访问构造器，只能在一个构造器内访问另一个构造器，且必须写在<strong>开头位置</strong></p>
<p>类变量    用来类实例的共享</p>
<p>类方法注意点</p>
<ol>
<li>静态方法内部无法使用this,super</li>
<li>静态方法无法调用非静态成员，而普通方法既可以调用非静态成员，也可以调用静态成员（成员包含了类中的属性，方法）</li>
</ol>
<p>代码块<br>普通代码块和静态代码块</p>
<p>生成对象时，其类中的调用顺序</p>
<ol>
<li>静态代码块和静态成员属性的初始化，若两个同时存在或有多个，根据定义顺序来调用</li>
<li>普通代码块，普通成员变量初始化</li>
<li>构造器</li>
</ol>
<p>在继承情况下，生成对象类中的调用顺序</p>
<ol>
<li>父类的静态代码块和静态成员属性的初始化</li>
<li>子类的静态代码块和静态成员属性的初始化</li>
<li>父类的普通代码块和普通成员属性初始化</li>
<li>父类构造器</li>
<li>子类的普通代码块和普通成员属性初始化</li>
<li>子类的构造器</li>
</ol>
<p>单例模式：保证类只有一个对象——懒汉式和饿汉式<br>懒汉式缺点：多线程下可能会出现问题，同时进入类方法的if语句，从而创建了多个类对象<br>final修饰符：不给修改和继承 ，一般在定义的时候赋值，也可以在构造器或代码块内赋值</p>
<p><strong>接口</strong>：转换器<br>实现接口：实现接口定义的方法<br>接入接口：通过接口调用方法<br>jdk8之后，接口有抽象方法，静态方法，默认实现方法</p>
<p>项目经理设计接口</p>
<p>一个普通类实现接口就必须将该接口的所有方法都实现。<strong>抽象类</strong>实现接口，可以不用实现接口的方法</p>
<p>一个类可同时接入多个接口，即要实现多个接口的所有方法<br>接口所有的属性都是<code>public static final</code>的—— 接口属性访问：接口名.属性名(静态)<br>类不能多继承但接口可以继承多个接口，接口不能继承其他类<br>如果子类需要扩展功能可以通过实现接口的方式来拓展</p>
<p>属性 方法 构造器 代码块 内部类<br><strong>内部类</strong>最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系<br>根据定义在外部类的位置类上<br>局部内部类(有类名)<br>	1. 定义在外部类的局部位置    可以访问外部类的所有成员，包括私有成员<br>	2. 不能添加访问修饰符，其地位是一个局部变量，但可以用final修饰——意味着不能被继承<br>	3. 作用域：仅仅在定义他的代码块或方法体内(<strong>局部变量</strong>)<br>	4. 局部内部类<strong>直接访问</strong>外部类成员<br>	5. 外部类在方法中创建内部类的实例，再去访问内部类的成员<br>	6. 如果内部类成员与外部类成员重名时，默认就近原则，如果想访问外部类成员：<br>	<code>(外部类)名.this.成员</code>去访问<br>匿名内部类(无类名)</p>
<ul>
<li>本质是个类，内部类，没名字（表面上），<strong>是个对象</strong></li>
<li>基于接口的内部类：简化开发，只使用一次</li>
<li>基于类的匿名内部类，重写原来类的方法，但不用子类的继承去重写</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>()&#123;  <span class="comment">// 重写接口的方法 &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>匿名内部类的作用在于，一般要实现接口的方法或是类的抽象方法时，都需要新写一个类来implements&#x2F;extends，才能够进行重写，后面若不再用，会造成资源浪费，而匿名内部类弥补了这一缺点，而且很便捷</li>
<li>把匿名内部类当作方法的实参(实现了接口的对象)，形参类型是接口类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f1(<span class="keyword">new</span> <span class="title class_">IL</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是一副名画~~...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>成员内部类(没有static): </p>
<ul>
<li>定义在成员的位置，可以加修饰符——地位等同于成员</li>
<li>内部类依旧直接访问外部类所有成员</li>
<li>外部类访问内部类需要创建对象再访问</li>
<li><strong>外部其他类可以访问成员内部类</strong><ul>
<li>用外部类对象实例化：<code>Outer.Inner inner = outer.new Inner()</code>,outer是Outer的实例</li>
<li>在外部类中编写一个方法，返回一个内部类的实例<br>静态成员部类(static)</li>
</ul>
</li>
<li>可以访问外部类所有静态成员，包括私有的，不能访问非静态成员</li>
<li>可以加修饰符——成员地位</li>
<li>内部类访问外部类成员直接：外部类.成员名，因为静态内部类只能访问静态成员</li>
<li><strong>外部其他类可以访问成员内部类</strong><ul>
<li><code>Outer.Inner inner = Outer.new Inner()</code></li>
<li>编写方法返回静态内部类的实例</li>
</ul>
</li>
</ul>
<h4 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h4><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>枚举类——枚: 一个一个 举： 例举 , 即把具体的对象一个一个例举出来的类<br>特点：只读，不需要修改<br>一组有限的特定的对象， 变量名一般大写（常量规范）<br>自定义枚举类：</p>
<ul>
<li>将构造器私有化</li>
<li>去掉setXXX方法</li>
<li>在类内部直接<code>new</code>新对象，对外暴露对象——<code>public static final</code></li>
<li>最后可以用<code>final</code>优化<br><code>enum</code>关键字实现枚举注意事项</li>
<li>class 改成 enum</li>
<li>直接使用常量名(构造器传参)</li>
<li>多个常量对象用都好隔开，最后一个有分号，并写在行首</li>
<li>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略</li>
<li>因为枚举类隐式地继承了Enum类，因此不能再继承其他类</li>
<li>枚举类也是类，可以实现接口</li>
</ul>
<p>父类enum的一些方法<br>name() 返回当前枚举对象的名字——指的是变量名，如果直接输出枚举对象默认用的toString方法，具体实现看toString的方法体<br>ordinal()返回当前类名在枚举对象的定义顺序，从零开始<br>values()返回一个枚举对象的数组  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Season3[] values = Season3.values();</span><br><span class="line"><span class="keyword">for</span>(Season3 season:values)&#123;   <span class="comment">//强for循环</span></span><br><span class="line">	System.out.println(season);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>valuesOf()将括号里的字符串转为枚举类象名字去查找，若存在则返回对象，否则报错<br>compareTo()将枚举对象和括号内的枚举类象进行序号的比较，编号1 - 编号2</p>
<h5 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h5><p><code>@Override</code> : 重写父类方法，只用于方法。显性标注则会在编译时检查语法是否正确<br><code>@Deprecated</code>: 表示已过时<br><code>@SuppressWarning</code>： 压制警告，可以将编译器中给出的警告消除掉</p>
<ul>
<li><code>@interface Override</code> 是注解类</li>
</ul>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>运行异常   编译异常<br>try-catch-finally  和  throws二选一  <strong>运行异常</strong>默认有throws</p>
<p>TCF细节</p>
<ul>
<li>catch部分可以不写，即只有try-finally，这么做的话，因为没有catch语句，即使获取错误也不会处理，而是直接报错，其目的就在于在报错前执行finally语句</li>
<li>选中认为会出现异常的语句，按ctrl+alt+t。选择try catch语句，即可自动生成该格式</li>
<li>可调用多个catch来防止多重异常，但父类Exception必须写在最后一个，且碰到一个错误就会返回异常，并不会将所有错误检测出，相当于建立了多重墙，并返回首个异常</li>
</ul>
<p>throws细节</p>
<ul>
<li>写在方法后面，可以抛出多个异常，用逗号分隔</li>
<li>当抛出的是运行异常时，即使不在方法后显示地写出<code>throws 异常名</code>,系统也会自动抛出，这也就解释了平时没有在函数后面写throws关键字，最后运行时还可以告诉我们异常，是由JVM输出的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="comment">//因为f2抛出的是运行异常，系统不要求必须处理，且f1默认会有throws方法继续往上抛出</span></span><br><span class="line">       f2();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span> <span class="keyword">throws</span> ArrayIndexOutOfBoundsException&#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当抛出的是编译异常时，必须显式地调用<code>throws 异常名</code>，否则无法传给调用该方法的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f4</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">       <span class="comment">//因为f4抛出的是编译异常，必须处理，try和throws二选一</span></span><br><span class="line">       f4();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f5</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           f4();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当子类重写了父类的方法并且在这两个方法中都抛出了异常时，子类抛出地异常类型必须和父类相同，或者是父类异常类型的子类</li>
</ul>
<h4 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AgeExecption</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeExecption</span><span class="params">(String message)</span> &#123;    </span><br><span class="line">        <span class="built_in">super</span>(message);      <span class="comment">//这个往父类深挖，其实就是返回实例化对象括号内的字符串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeExecption</span>(<span class="string">&quot;年龄超出范围&quot;</span>);     <span class="comment">//throw+实体化对象</span></span><br></pre></td></tr></table></figure>
<p>注意：这里用到的是<strong>throw</strong>，和上面的throws是两个东西，下面将进行区分</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>使用位置</th>
<th>后面跟的</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>throws</td>
<td>方法体（）后</td>
<td>异常类名</td>
<td>抛出异常，返回给调用它的函数</td>
</tr>
<tr>
<td>throw</td>
<td>方法体内</td>
<td>异常类对象</td>
<td>返回异常，一般结合try语句，到这句就交给catch</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h4><h4 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h4><p>八大包装类，除下面整型变化其他就是首字母大小写的变化。 六个数类的父类是Number类</p>
<ul>
<li>int -&gt; Integer<br><strong>1. 包装类和基本数据类型的转换</strong><br>装箱与拆箱<br>jdk5之后可以自动开箱自动装箱</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">true</span> : Integer(<span class="number">1</span>) : Double(<span class="number">2</span>);  </span><br><span class="line"><span class="comment">// 输出是1.0  三元运算符看成一个整体，会自动提升精度</span></span><br></pre></td></tr></table></figure>
<p>2.包换类和String的相互转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;  </span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>; <span class="comment">// 对原先的数据类型没有影响  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> i.toString();  </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(<span class="number">108</span>); <span class="comment">// 6个数类和对象类都可以  </span></span><br><span class="line"><span class="comment">// String -&gt;  包装类Integer  </span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;234&quot;</span>  </span><br><span class="line"><span class="type">Integer</span> <span class="variable">int1</span> <span class="operator">=</span> Integer.parseInt(s3);  </span><br><span class="line"><span class="type">Integer</span> <span class="variable">int2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(s3);  <span class="comment">// 版本不适用了</span></span><br></pre></td></tr></table></figure>
<p>注意：只要有基本数据类型， <code>==</code>就是判断值相不相等</p>
<p><img src="https://concentration-blog.oss-cn-shenzhen.aliyuncs.com/img/202508082317736.png"></p>
<ul>
<li>String类实现了Serializable接口，表明其是可串行化的（可以在网络上传输）</li>
<li>字符串用utf8编码，不区分字母和汉字都是两个字符</li>
<li>String类实现了comparable接口，表示是可比较的</li>
<li>用final修饰，是最终类，不能被继承</li>
<li>在底层(本质)是一个char数组   ——  <em>private final char value[]  不可以修改(value 的地址不能修改)但是单个字符的内容可以变化。</em></li>
</ul>
<p>字符串两种创建方式的 区别</p>
<p><img src="https://concentration-blog.oss-cn-shenzhen.aliyuncs.com/img/202508082318894.png"></p>
<p>字符串特性</p>
<p>字符串常量相加，最后返回的字符串指向的是常量池中的地址。字符串变量相加，最后返回的字符串指向的是堆中的地址<br><img src="https://concentration-blog.oss-cn-shenzhen.aliyuncs.com/img/202508082318535.png"></p>
<p>String和StringBuffer对比</p>
<ul>
<li>StringBuffer类的数组value是存储在堆中的，而String类的字符串一般存储在常量池中（构造器方法虽然对象在堆中，但其value数组还是指向了常量池中的具体值）<br>StringBuffer常用构造器：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  <span class="comment">// 默认16长度</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="type">int</span> cap);  <span class="comment">// 定义大小</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);  <span class="comment">// 长度为str.length + 16</span></span><br></pre></td></tr></table></figure>

<p>转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String -&gt; StringBuffer</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line"> <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s1);   <span class="comment">// 构造器  </span></span><br><span class="line"> <span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>().append(s1);   <span class="comment">// 利用append()方法  </span></span><br><span class="line"><span class="comment">// StringBuffer -&gt; String  </span></span><br><span class="line"> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sb1.toString();  <span class="comment">// 用toString()方法  </span></span><br><span class="line"> <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb1);   <span class="comment">// 用构造器</span></span><br></pre></td></tr></table></figure>
<p>常用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;hello,张三丰赵敏true10.5&quot;</span></span><br><span class="line">s.replace(<span class="number">9</span>,<span class="number">11</span>,<span class="string">&quot;周芷若&quot;</span>);   <span class="comment">// 替换长度可以不等， &quot;hello,张三丰周芷若true10.5&quot;</span></span><br><span class="line">s.insert(<span class="number">9</span>,<span class="string">&quot;赵敏&quot;</span>)      <span class="comment">// &quot;hello,张三丰  赵敏周芷若true10.5&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>StringBuilder</strong></p>
<ul>
<li>StringBuilder不是线程安全的，单线程最优选。方法基本和StringBuffer一样</li>
<li>StringBuilder的方法，没有做互斥的处理,即没有synchronized关键字,因此在单线程的情况下使用</li>
</ul>
<p>String、StringBuffer和StringBuilder的比较</p>
<ul>
<li>就执行速度而言，StringBuilder &gt; StringBuffer &gt; String，String慢的原因在于每次赋新值都是创建新的对象（只有在同名时才不会）（存储的是字符串常量），效率很低。而StringBuffer和StringBuilder存储的是字符串变量，直接进行原地修改即可，效率高，而StringBuilder因为使用场景是单线程，速度最快</li>
<li>就安全性而言，StringBuffer&gt;StringBuilder,因为StringBuffer使用场景是多线程，线程保护机制比StringBuilder要强（体现在其方法都用synchronized进行修饰）<br>三种String类的<strong>适用场景</strong>：</li>
</ul>
<ol>
<li>若字符串不需要经常修改，且多个对象使用的是同一个字符串变量名（会直接指向常量池中的同名字符串），就用String类。String类的复用性很高</li>
<li>若字符串需要经常修改，且运行在多线程环境下，就用StringBuffer类</li>
<li>若字符串需要经常修改，且运行在单线程环境下，就用StringBuilder类</li>
</ol>
<h4 id="常用类-1"><a href="#常用类-1" class="headerlink" title="常用类"></a>常用类</h4><p>Array类   静态方法，数组直接用<br>System类<br>Date类<br>第一类获取时间的形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Date date=<span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(date);</span><br><span class="line"><span class="comment">//Date -&gt; String</span></span><br><span class="line"><span class="comment">// 借用SimpleDateFormatter类，在实例化时输入要格式化的形式，再调用`对象名.format()`的方式将Date类对象转为String类对象</span></span><br><span class="line">SimpleDateFormatter sdf=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>); </span><br><span class="line"><span class="comment">//字母不可更换，每个字母及个数都有意义</span></span><br><span class="line">String s1=sdf.format(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">// String -&gt; Date</span></span><br><span class="line"><span class="comment">// 依旧使用上述sdf对象  字符串的格式要和sdf初始化的格式一样(否则报错)  格式依旧默认</span></span><br><span class="line"><span class="comment">// 要按照自定义格式还需调用sdf.format()</span></span><br></pre></td></tr></table></figure>
<p><strong>BigInteger</strong>大数据类： 加减乘除用对应的方法。 还有高精度浮点类 <strong>BigDecimal</strong><br><strong>Calendar</strong>类：抽象类，无法被实体化，仅能通过getInstance（其类中定义的public static方法）获取类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Calendar c1=Calendar.getInstance();</span><br><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line">System.out.println(c1.get(Calendar.YEAR));</span><br><span class="line">System.out.println(c1.get(Calendar.MONTH)+<span class="number">1</span>);    <span class="comment">//若不用c1.get，即Calendar.YEAR——获得的是默认值。 月份从0开始计算</span></span><br><span class="line">System.out.println(c1.get(Calendar.DATE));</span><br><span class="line">System.out.println((c1.get(Calendar.HOUR)+<span class="number">12</span>)%<span class="number">24</span>);</span><br><span class="line">System.out.println(c1.get(Calendar.HOUR_OF_DAY));   <span class="comment">//获取到24小时制的时间</span></span><br><span class="line">System.out.println(c1.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(c1.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure>
<p><strong>LocalDateTime</strong>类：线程安全<br>其下还包含了LocalDate和LocalTime类，LocalDateTime类是最全的，返回年月日时分秒</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime a=LocalDateTime.now();</span><br><span class="line"><span class="comment">//获取时间中的一部分</span></span><br><span class="line">        System.out.println(a.getYear());</span><br><span class="line">        System.out.println(a.getMonth());    <span class="comment">//November</span></span><br><span class="line">        System.out.println(a.getMonthValue());  <span class="comment">//11</span></span><br><span class="line">        System.out.println(a.getDayOfMonth());</span><br><span class="line">        System.out.println(a.getHour());</span><br><span class="line">        System.out.println(a.getMinute());</span><br><span class="line">        System.out.println(a.getSecond());</span><br><span class="line"><span class="comment">// 通过`plus时间`的形式，加上小时/天数/秒数等时间，从而获得未来的一个时间</span></span><br><span class="line"><span class="comment">// 过去就minus时间</span></span><br><span class="line">LocalDateTime a1=a.plusYears(<span class="number">25</span>);    <span class="comment">//加上25年之后的时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化 LocalDateTime -&gt; String</span></span><br><span class="line"><span class="comment">//利用DateTimeFormatter 注意是调用其方法ofPattern 而不是创建对象</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH:mm:ss&quot;</span>);</span><br><span class="line">        LocalDateTime a=LocalDateTime.now();</span><br><span class="line">        <span class="comment">//同样使用String类接收</span></span><br><span class="line">        String s1=dateTimeFormatter.format(a);</span><br><span class="line">        System.out.println(s1);</span><br></pre></td></tr></table></figure>

<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><h5 id="集合体系图【背！！！】"><a href="#集合体系图【背！！！】" class="headerlink" title="集合体系图【背！！！】"></a>集合体系图【背！！！】</h5><p><img src="https://concentration-blog.oss-cn-shenzhen.aliyuncs.com/img/202508082319535.png"></p>
<p>Collection 和 Map<br>Collection 每次记录单个元素，Map记录的是键值对</p>
<h5 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增删改查crud</span></span><br><span class="line">add(), remove(), isEmpty(), size(), contains()<span class="comment">// 检查对象是否存在</span></span><br><span class="line"><span class="comment">// 添加多个元素</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">arrayList.add(<span class="string">&quot;红楼梦&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;西游记&quot;</span>);</span><br><span class="line">list.addAll(arrayList);  <span class="comment">// 对应的有removeAll</span></span><br><span class="line">System.out.println(list.contains(<span class="string">&quot;三国演义&quot;</span>));</span><br><span class="line">        <span class="comment">//6.检查多个元素是否存在</span></span><br><span class="line">System.out.println(list.containsAll(arrayList));</span><br></pre></td></tr></table></figure>
<p>用迭代器遍历集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> col.iterator();    <span class="comment">//初始指向第一个元素的上一位置</span></span><br><span class="line">     <span class="keyword">while</span> (iterator.hasNext())&#123;         <span class="comment">//若下一个元素存在</span></span><br><span class="line">        Object obj= iterator.next(); <span class="comment">//向下移动一步并输出当前指向的元素</span></span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 增强for循环</span></span><br><span class="line">		Collection col=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">//先在集合中放入对象</span></span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;三国演义&quot;</span>,<span class="string">&quot;罗贯中&quot;</span>));</span><br><span class="line">        col.add(<span class="keyword">new</span> <span class="title class_">Book</span>(<span class="string">&quot;红楼梦&quot;</span>,<span class="string">&quot;曹雪芹&quot;</span>));</span><br><span class="line">        <span class="comment">//底层实现就是迭代器那一套 hasnext() next()</span></span><br><span class="line">        <span class="keyword">for</span>(Object object:col)&#123;     <span class="comment">//将col中的元素逐个赋给object</span></span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>生成迭代器循环遍历的快捷指令<code>itit</code></li>
<li>查看所有快捷指令<code>ctrl+j</code></li>
</ul>
<h5 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h5><p>存储数据是可重复的，有序的，实现了Collection接口，常用方法和Collection类似<br><strong>ArrayList数组无参扩容规则</strong>：<br>	1. 初始化ArrayList对象，数组elementData(底层存储)容量为0<br>	2. 添加第一个数据之后扩容为10<br>	3. 而后每超出容量扩容1.5倍<br>有参对象的类似：<br>	1. 初始化ArrayList对象时，数组elementData的容量为初始化时设置的参数<br>	2. 每当容量达到上限，扩充为当前容量的1.5倍<br><strong>Vector</strong>类的无参对象初始化和扩容规则：<br>	1. 初始化类对象时，就分配10的数组空间<br>	2. 后续扩容时，每次更新的容量都是原容量的两倍<br>带参类似</p>
<h6 id="ArrayList和Vector的比较"><a href="#ArrayList和Vector的比较" class="headerlink" title="ArrayList和Vector的比较"></a>ArrayList和Vector的比较</h6><table>
<thead>
<tr>
<th>类名</th>
<th>适用场景</th>
<th>初始化机制</th>
<th>扩容机制</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>单线程</td>
<td>无参：初始长度为0，插入第一个元素之前，数组扩容为10。带参：初始长度为指定长度</td>
<td>扩充为当前容量的1.5倍</td>
</tr>
<tr>
<td>Vector</td>
<td>多线程，其方法都有synchronized</td>
<td>无参：初始长度为10。带参：初始长度为指定长度</td>
<td>扩充为当前容量的2倍</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h5><p>底层实现的双向链表，增删方便</p>
<h6 id="LinkedList和ArrayList的比较"><a href="#LinkedList和ArrayList的比较" class="headerlink" title="LinkedList和ArrayList的比较"></a>LinkedList和ArrayList的比较</h6><table>
<thead>
<tr>
<th>类</th>
<th>底层存储数据</th>
<th>使用场景</th>
<th>安全性</th>
</tr>
</thead>
<tbody><tr>
<td>LinkedList</td>
<td>双链表</td>
<td>增删用的比较多时</td>
<td>不安全</td>
</tr>
<tr>
<td>ArrayList</td>
<td>可变数组</td>
<td>改查用的比较多时</td>
<td>不安全</td>
</tr>
</tbody></table>
<h5 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h5><p>无序，不能用索引，取出顺序与存放顺序不同，但取出顺序是固定的。</p>
<h6 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h6><p>创建HashSet时，底层创建的是HashMap,因此本质研究的是HashMap的底层数据结构，底层实现<strong>数组+链表</strong><br><strong>HashSet扩容机制：</strong></p>
<ol>
<li>向table里面放数据，数据哈希值（改哈希值不是真正的，通过&gt;&gt;&gt;16计算出来的）对应索引的数组没数据直接放。</li>
<li>有数据就用equals方法(重写)再放，</li>
<li>在java8中，一条链表元素到达设定值(默认为8)，并且table的容量大于等于64就会树化(红黑树)，否则就继续扩容。</li>
</ol>
<ul>
<li>注意：有设置一个缓冲值threhold&#x3D; 当前容量$*$因子(0.75)，数据个数达到这个数就会扩容(不论是在table的还是在链表上的)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此函数包含了所有插入哈希表的数据遇到的各种情况</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">                   <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)    <span class="comment">//在table上匹配</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);  <span class="comment">//该位置空，加入</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//转入此判断语句，代表发生哈希冲突，table表上相同位置已存有元素，根据冲突的不同情况，又分为以下三种</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;    <span class="comment">//局部变量，用到时再声明</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;   <span class="comment">//到这句话，p.hash=(n - 1) &amp; hash,这是由上面第二个判断语句先赋值后判断的</span></span><br><span class="line">                ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">//若哈希值相等且满足以下其一情况</span></span><br><span class="line">                  <span class="comment">//1.两个对象的地址相等</span></span><br><span class="line">                  <span class="comment">//2.两个对象经过equals比较相等（具体比的什么取决于每个类对于equals有没有重写，比如String的equals，就是比较字符串值是否相等）</span></span><br><span class="line">                e = p;   <span class="comment">//用于衔接下面的if (e != null)判断</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)    <span class="comment">//判断是否为红黑树</span></span><br><span class="line">                <span class="comment">//用红黑树的putTreeVal方法插入数据</span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//到这个分支，证明哈希冲突出现在了拉链支路上，即在拉链上进行匹配时可能出现问题</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;    <span class="comment">//在拉链上逐一匹配</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;    <span class="comment">//匹配到最后，未出现冲突，尾部插入元素</span></span><br><span class="line">                        <span class="comment">//注意是先转到下一个p.next，再比较是否为控制，这种代码写的很优美</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 插入后检查该拉链上元素个数是否&gt;=8，满足则扩展成红黑树treeifyBin</span></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        treeifyBin()中会先判断table数组容量是否小于64，符合则实际上进行的是数组扩容操作resize()，否则才是真正地创建红黑树</span></span><br><span class="line"><span class="comment">                        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span></span><br><span class="line"><span class="comment">            				resize();</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;     <span class="comment">//因为这个循环是没有终止条件的，需手动退出</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;    <span class="comment">//在拉链上匹配到了相同元素，插入失败</span></span><br><span class="line">                        ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;    <span class="comment">//因为开始时先e=p.next,这两个组合相当于移到下一个元素</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;    <span class="comment">//return的是旧值，而不是null，代表添加元素失败</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h6 id="LinkHashSet"><a href="#LinkHashSet" class="headerlink" title="LinkHashSet"></a>LinkHashSet</h6><p>数据结构为table数组+双向链表，拥有头尾指针，每个节点也有头尾指针，有顺序不允许添加重复元素<br>重写equals方法可以利用IDEA的封装调用<br><strong>存储数据的底层实现：</strong></p>
<ol>
<li>初始扩容16容量</li>
<li>当达到门槛值的75%时，进行扩容，扩容为当前容量的两倍</li>
</ol>
<h5 id="Map接口（JDK8）"><a href="#Map接口（JDK8）" class="headerlink" title="Map接口（JDK8）"></a>Map接口（JDK8）</h5><p>键值对，和collection接口平行（即不属于collection)</p>
<ol>
<li>键不可重复，若对重复的键赋予不同的值，<strong>新值会覆盖旧值</strong></li>
<li>值可以重复</li>
<li>键可以为空，但只能有一个空。值可以为空，不限个数</li>
<li>可通过键找到值</li>
<li>存储的键和值可以是任何引用型类型，会存储在HashMap$Node对象中。Node是HashMap的一个静态内部类，包含hash值，键值对，下一元素的指针等，可将链表进行连接</li>
</ol>
<h6 id="Map常用方法"><a href="#Map常用方法" class="headerlink" title="Map常用方法"></a>Map常用方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line"> <span class="comment">//插入数据</span></span><br><span class="line"> <span class="type">HashMap</span> <span class="variable">hashMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    hashMap.put(<span class="number">1</span>,<span class="string">&quot;syx&quot;</span>);</span><br><span class="line">    hashMap.put(<span class="literal">null</span>,<span class="string">&quot;syx&quot;</span>);</span><br><span class="line">    hashMap.put(<span class="number">2</span>,<span class="string">&quot;wanke&quot;</span>);</span><br><span class="line">    hashMap.put(<span class="number">3</span>,<span class="string">&quot;add&quot;</span>);</span><br><span class="line">    <span class="comment">//查找元素</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> hashMap.get(<span class="number">3</span>);</span><br><span class="line">    System.out.println(object);</span><br><span class="line">    <span class="comment">//根据键删除键值对</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">remove</span> <span class="operator">=</span> hashMap.remove(<span class="number">2</span>);</span><br><span class="line">    System.out.println(hashMap);</span><br><span class="line">    <span class="comment">//检查映射是否为空</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">empty</span> <span class="operator">=</span> hashMap.isEmpty();</span><br><span class="line">    System.out.println(empty);</span><br><span class="line">    <span class="comment">//查看是否包含某个键</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> hashMap.containsKey(<span class="literal">null</span>);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    <span class="comment">//查看当前的映射个数</span></span><br><span class="line">    System.out.println(hashMap.size());</span><br><span class="line">    <span class="comment">//清空所有映射</span></span><br><span class="line">    hashMap.clear();</span><br><span class="line">    System.out.println(hashMap);</span><br></pre></td></tr></table></figure>
<h6 id="Map六种遍历方式"><a href="#Map六种遍历方式" class="headerlink" title="Map六种遍历方式"></a>Map六种遍历方式</h6><p>一共有六种，细分的话就是三种，每种包含了for循环和迭代器循环两种方式，能够用迭代器，因为得到的集合都是实现了collection接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map六种遍历方式</span></span><br><span class="line">		<span class="comment">//1.先获取key值，再通过key获取值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;法一：&quot;</span>);</span><br><span class="line">        <span class="type">Set</span> <span class="variable">keyset</span> <span class="operator">=</span> hashMap.keySet();</span><br><span class="line">        <span class="comment">//增强for循环</span></span><br><span class="line">        <span class="keyword">for</span> (Object object :keyset) &#123;</span><br><span class="line">            System.out.println(object+<span class="string">&quot;-&quot;</span>+hashMap.get(object));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//迭代器  因为运行类型是keyset,是实现了AbstractSet的类，因此可以用迭代器遍历</span></span><br><span class="line">        System.out.println(<span class="string">&quot;法二：&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keyset.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator.next();    <span class="comment">//这里的next就是key</span></span><br><span class="line">            System.out.println(next+<span class="string">&quot;-&quot;</span>+hashMap.get(next));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取value进行遍历  但这种方法无法获得key</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> hashMap.values(); <span class="comment">// 注意values是集合类型</span></span><br><span class="line">        <span class="comment">//增强for循环Set</span></span><br><span class="line">        System.out.println(<span class="string">&quot;法三：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(Object obj:values)&#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//迭代器  原理同法二</span></span><br><span class="line">        System.out.println(<span class="string">&quot;法四：&quot;</span>);</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> values.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator1.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.通过EntrySet进行遍历  涉及到向下转型以及Entry的两个方法</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">set1</span> <span class="operator">=</span> hashMap.entrySet();</span><br><span class="line">        <span class="comment">//增强for循环</span></span><br><span class="line">        System.out.println(<span class="string">&quot;法五：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object object :set1) &#123;</span><br><span class="line">            <span class="comment">//此时每个object实际上为Node类型</span></span><br><span class="line">            <span class="comment">//转成Entry类型，可以使用其方法</span></span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">object1</span> <span class="operator">=</span> (Map.Entry) object;</span><br><span class="line">            System.out.println(object1.getKey()+<span class="string">&quot;-&quot;</span>+object1.getValue());    <span class="comment">//  Map.Entry  自带的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;法六：&quot;</span>);</span><br><span class="line">        <span class="comment">//迭代器</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> set1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator2.next(); <span class="comment">// next是 HashMap$Node -&gt; 实现 Map.Entry方法(getKey(),getValue())</span></span><br><span class="line">            Map.<span class="type">Entry</span> <span class="variable">next1</span> <span class="operator">=</span> (Map.Entry) next;</span><br><span class="line">            System.out.println(next1.getKey()+<span class="string">&quot;-&quot;</span>+next1.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="HashMap底层机制"><a href="#HashMap底层机制" class="headerlink" title="HashMap底层机制"></a>HashMap底层机制</h6><p>因为HashSet的底层实现就是HashMap，因此其底层的存储数据和扩容代码相同，唯一的区别在于HashMap在存储相同键不同值时，新值会把旧值覆盖，而HashSet是不允许存相同值<br>注：HashMap是线程不安全的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这段代码是底层putVal函数中的一部分</span></span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">             <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;    <span class="comment">//用oldvalue存储旧值</span></span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)   <span class="comment">//onlyIfAbsent==false</span></span><br><span class="line">                 e.value = value;    <span class="comment">//新值赋给e.value</span></span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="keyword">return</span> oldValue;     <span class="comment">//最后返回旧值</span></span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p><strong>HashMap总结</strong>：</p>
<ol>
<li>在创建对象时，底层生成HashMap$Node[] table数组，用于存储每个键值对（视为一个Node)，初始数组<strong>容量为空</strong></li>
<li>加入第一个数据之前，会触发数组扩容resize()，数组容量变为16，因子为0.75，门槛容量为12</li>
<li>后续继续添加k-v时，会根据key的hash值得到数组下标的索引，若索引处没有值，则直接加入，若索引处有元素，判断两个元素的key是否相等，相等则覆盖，不相等则考虑在后面的链表&#x2F;红黑树上进行插入，在链表上插入时就会涉及扩容以及链表-&gt;红黑树机制</li>
<li>当一条链表上的元素&gt;&#x3D;8个时，会触发转为树的操作，不过在转为树之前会检查当前数组的长度是否&gt;&#x3D;64，若&lt;64则进行数组扩容，容量变为原容量的两倍，若&gt;&#x3D;64则转换为红黑树</li>
<li>数组扩容还会在当前数组元素（包含链表上的元素个数）个数&gt;&#x3D;门槛数时触发 <img src="https://concentration-blog.oss-cn-shenzhen.aliyuncs.com/img/202508082320876.png"></li>
</ol>
<p><strong>HashTable</strong>:</p>
<ul>
<li>HashTable是实现了Map接口的类，和HashMap是平行关系，方法基本和HashMap一样</li>
<li>HashTable适用于多线程，其键和值都不能为空，否则抛出异常</li>
<li>初始化对象会创建HashTable[] table 数组，初始容量为11，加载因子0.75</li>
<li>扩容机制为：<code>当前容量 * 2 + 1</code></li>
</ul>
<h6 id="HashTable对比HashMap"><a href="#HashTable对比HashMap" class="headerlink" title="HashTable对比HashMap"></a>HashTable对比HashMap</h6><table>
<thead>
<tr>
<th>类</th>
<th align="center">适用场景</th>
<th align="center">效率</th>
<th align="center">键值对能否为空</th>
<th align="center">初始数组容量</th>
<th>扩容机制</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td align="center">单线程</td>
<td align="center">高</td>
<td align="center">可以</td>
<td align="center">16</td>
<td>原容量*2</td>
</tr>
<tr>
<td>HashTable</td>
<td align="center">多线程</td>
<td align="center">低</td>
<td align="center">不可以</td>
<td align="center">11</td>
<td>原容量*2+1</td>
</tr>
<tr>
<td>Properties：</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>Properties是继承了HashTable的类，因此其键值对也不能为空</li>
<li>多用于读写xxx.properties型的文件</li>
</ul>
<h5 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h5><p>对各种集合（Set， List， Map）进行各种操作的工具类<br>和Collection区分，Collection是接口，Collections是类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Collections工具类 可用于对集合的各种操作</span></span><br><span class="line">        <span class="comment">//以ArrayList为例</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        arrayList.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;jerry&quot;</span>);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        <span class="comment">//1.翻转list</span></span><br><span class="line">        Collections.reverse(arrayList);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        <span class="comment">//2.随机生成顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            Collections.shuffle(arrayList);</span><br><span class="line">            System.out.println(arrayList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.排序  默认是用compareto排序</span></span><br><span class="line">        Collections.sort(arrayList);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        <span class="comment">//自定义排序顺序以及规则</span></span><br><span class="line">        Collections.sort(arrayList, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="comment">//按长度进行排序</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ((String)o1).length()-((String)o2).length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        <span class="comment">//交换两个元素的位置</span></span><br><span class="line">        Collections.swap(arrayList,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(arrayList);</span><br><span class="line">        <span class="comment">//获取最大值（默认字母排序，也可以通过比较器进行自定义）</span></span><br><span class="line">        System.out.println(Collections.max(arrayList));</span><br><span class="line">        <span class="comment">//获取最小值</span></span><br><span class="line">        System.out.println(Collections.min(arrayList));</span><br><span class="line">        <span class="comment">//拷贝元素到另一个list中</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">desc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arrayList.size(); i++) &#123;</span><br><span class="line">            desc.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.copy(desc,arrayList);  <span class="comment">//注意：若目标容量小于原数组容量，则会报错数组越界</span></span><br><span class="line">        System.out.println(desc);</span><br><span class="line">        <span class="comment">//查找某一元素在数组中出现的频率</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tom</span> <span class="operator">=</span> Collections.frequency(desc, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        System.out.println(tom);</span><br><span class="line">        <span class="comment">//将指定元素值进行替换</span></span><br><span class="line">        Collections.replaceAll(arrayList,<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;汤米&quot;</span>);</span><br><span class="line">        System.out.println(arrayList);</span><br></pre></td></tr></table></figure>

<h5 id="集合小结"><a href="#集合小结" class="headerlink" title="集合小结"></a>集合小结</h5><p><strong>TreeMap的去重</strong></p>
<ul>
<li>当我们为了使输出是有序的，这时会自定义排序方法，当排序规则得出<code>==</code>时，就会去重。</li>
<li>当我们并没有自定义排序方法，即在创建TreeMap对象时调用的是空值构造器，系统内部也会自动调用一个比较器，这个比较器是基于当前输入数据类型的实现了Comparable接口的比较器，再使用其中的compareTo方法进行比较</li>
<li>也就是说，<strong>如果自己定义了一个类，却没有实现Comparable接口，那么该类的对象是无法插入进TreeMap类的对象的，底层在去重代码那一块向上转型为Comparable接口类型时会报错</strong></li>
</ul>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>传统做法问题：<br>	不能对加入到集合的数据类型进行约束<br>	向下转型的类型多，存在转换异常的隐患</p>
<p>泛型可以用于类，接口，集合的定义中，在实体化对象时将泛型的内容变为具体的数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里以集合为例</span></span><br><span class="line">		<span class="comment">//底层源码public class ArrayList&lt;E&gt;，E为泛型，在实体化对象时，Dog替代了E</span></span><br><span class="line">		ArrayList&lt;Dog&gt; dogs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Dog&gt;();</span><br><span class="line">        dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;tom&quot;</span>));</span><br><span class="line">        dogs.add(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;happt&quot;</span>));</span><br><span class="line">        <span class="comment">//加入别的类则会报错</span></span><br><span class="line">        <span class="comment">//dogs.add(new Cat(&quot;cat&quot;));</span></span><br><span class="line">        <span class="comment">//在遍历时，可以直接赋予Dog类型，而不用再用Object -&gt; Dog进行向下转型</span></span><br><span class="line">        <span class="keyword">for</span> (Dog object :dogs) &#123;</span><br><span class="line">            System.out.println(object);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>由此可看出泛型的好处：</p>
<ol>
<li>有效保证了程序的安全性，控制了输入数据的类型</li>
<li>跳过了向下转型</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型作用：用于在类定义时充当类的属性类型/方法返回值类型/方法形参类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;E&gt;&#123;</span><br><span class="line">    E s;   <span class="comment">//在实体化对象时，定义的类型会替代E</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(E s)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">(E s)</span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(s.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&lt;String&gt; person = <span class="keyword">new</span> <span class="title class_">Person</span>&lt;String&gt;(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line"><span class="comment">//泛型的具体数据类型在定义时就已确定，若输入不符合类型的值，会直接显示有误</span></span><br><span class="line"><span class="comment">//Person&lt;String&gt; person1 = new Person&lt;String&gt;(100);</span></span><br></pre></td></tr></table></figure>
<h5 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h5><p>只能传引用类型，不能传基本数据类型<br>指定泛型的类型之后，可以传入该类型以及子类<br>简写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器自动推断类型，推荐写法  </span></span><br><span class="line">Pig&lt;A&gt; pig = <span class="keyword">new</span> <span class="title class_">Pig</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">A</span>());</span><br><span class="line"><span class="comment">// 没有给泛型指定，默认是Object</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">ayy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  <span class="comment">// ArrayList&lt;Object&gt; ayy = new ArrayList&lt;Object&gt;();</span></span><br></pre></td></tr></table></figure>
<h5 id="自定义泛型"><a href="#自定义泛型" class="headerlink" title="自定义泛型"></a>自定义泛型</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后面有泛型的类就是泛型类  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span>&lt;T,R,M&gt;&#123;  </span><br><span class="line">    String name;  </span><br><span class="line">    <span class="comment">// 普通成员可以使用泛型  </span></span><br><span class="line">    R r;  </span><br><span class="line">    M m;  </span><br><span class="line">    T t;  </span><br><span class="line">    <span class="comment">// 使用泛型的数组不能实例化，数组在创建的时候不能确定T的类型，无法确定内存。  </span></span><br><span class="line">    T[] ts = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">8</span>];  </span><br><span class="line">    <span class="comment">// 静态成员不能使用泛型， 静态是和类相关的，类加载的时候对象还没有创建，不能确定类型  </span></span><br><span class="line">    <span class="comment">//public static void m1(M m)&#123;&#125;  </span></span><br><span class="line">    <span class="comment">//public static R r;  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tiger</span><span class="params">(String name, R r, M m, T t)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">        <span class="built_in">this</span>.r = r;  </span><br><span class="line">        <span class="built_in">this</span>.m = m;  </span><br><span class="line">        <span class="built_in">this</span>.t = t;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">getR</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> r;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setR</span><span class="params">(R r)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.r = r;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> M <span class="title function_">getM</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> m;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setM</span><span class="params">(M m)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.m = m;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> t;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setT</span><span class="params">(T t)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.t = t;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>泛型接口的泛型实体化，是在其被其他接口继承时，或是被类实现时。一旦实体化，其内部的泛型方法，属性都会自动变为具有实体化属性的形式，而不是再用泛型的字母代替</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用接口IA继承泛型接口Iusb</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> <span class="keyword">extends</span> <span class="title class_">Iusb</span>&lt;String,Integer&gt;&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用类A实现接口IA</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="comment">//U和R会自动替换为String,Integer,本质在于IA继承时将泛型具体化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">f1</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> IA.<span class="built_in">super</span>.f1(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Iusb</span>&lt;U,R&gt;&#123;</span><br><span class="line">    <span class="comment">//不能用泛型去修饰接口中的属性，因为其属性自带public static</span></span><br><span class="line">    <span class="comment">//U a;</span></span><br><span class="line">    R <span class="title function_">get</span><span class="params">(U u)</span>;</span><br><span class="line">    <span class="comment">//抽象方法，隐藏public abstract</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">(R r)</span>;</span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="keyword">default</span> U <span class="title function_">f1</span><span class="params">(R r)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;E e&#125; <span class="comment">// 形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">f1</span><span class="params">()</span>&#123;&#125;    <span class="comment">//返回值为泛型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(T t)</span>&#123;&#125;   <span class="comment">//函数参数为泛型</span></span><br></pre></td></tr></table></figure>

<p>泛型没有继承性，他就是一种限制</p>
<h5 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a>事件处理机制</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">event01</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">    <span class="comment">//初始化面板</span></span><br><span class="line">    MyPanel mp=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">event01</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//画框构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">event01</span><span class="params">()</span>&#123;</span><br><span class="line">        mp=<span class="keyword">new</span> <span class="title class_">MyPanel</span>();</span><br><span class="line">        <span class="built_in">this</span>.add(mp);</span><br><span class="line">        <span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">800</span>,<span class="number">800</span>);</span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//串口也要添加对键盘的监听</span></span><br><span class="line">        <span class="built_in">this</span>.addKeyListener(mp); <span class="comment">// mp实现了该接口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建画板</span></span><br><span class="line"><span class="comment">//实现接口KeyListener，从而对键盘进行监听</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPanel</span> <span class="keyword">extends</span> <span class="title class_">JPanel</span> <span class="keyword">implements</span> <span class="title class_">KeyListener</span> &#123; <span class="comment">// 监听键盘事件</span></span><br><span class="line">    <span class="comment">//定义初始位置</span></span><br><span class="line">    <span class="type">int</span> x=<span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> y=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//重写paint</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.paint(g);</span><br><span class="line">        <span class="comment">//绘制小圆</span></span><br><span class="line">        g.fillOval(x,y,<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出字符时，该方法触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyTyped</span><span class="params">(KeyEvent e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按下键盘按键时被触发</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyPressed</span><span class="params">(KeyEvent e)</span> &#123;</span><br><span class="line">        <span class="comment">//System.out.println(e.getKeyChar()+&quot;被按下&quot;);</span></span><br><span class="line">        <span class="comment">//针对按下上下左右进行位移操作</span></span><br><span class="line">        <span class="keyword">if</span>(e.getKeyCode()==KeyEvent.VK_UP)&#123;</span><br><span class="line">            <span class="comment">//向上走  因为画框左上坐标为（0，0）</span></span><br><span class="line">            y--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getKeyCode()==KeyEvent.VK_DOWN) &#123;</span><br><span class="line">            y++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e.getKeyCode()==KeyEvent.VK_LEFT)&#123;</span><br><span class="line">            x--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e.getKeyCode()==KeyEvent.VK_RIGHT)&#123;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每次移动都要刷新。否则看不到</span></span><br><span class="line">        <span class="built_in">this</span>.repaint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//松开键盘按键时进行操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keyReleased</span><span class="params">(KeyEvent e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>每次移动要手动刷新页面，即要加上<code>this.repaint()</code></li>
<li>画框也要实现对键盘的监听，即<code>this.addKeyListener()</code>，因为画板实现了KeyListener接口，因此画板的实例化对象就是该接口的引用，可以作为参数加入addKeyListener（）方法中</li>
<li>需要不断变化的参数，可以在初始时设置为变量</li>
</ol>
<p>委派事件模型：事件发生和事件处理是靠一个事件对象关联起来的，<br>事件源(按钮，窗口)被触发(有事件【键盘事件，鼠标事件】发生)生成对象，事件监听者收到后做处理，事件对象有很多信息。</p>
<p>Cpu的并行和并发</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>常见的创建线程有两种：继承Thread类，实现Runnable接口<br>继承Thread类，要重写其中的run方法，而这个run方法是在Runnable接口中定义的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.start();    <span class="comment">//启动线程 cat.run()只是一个普通的方法，不启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">8</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;小猫叫&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);    <span class="comment">//休眠一秒钟</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>主线程和子线程</strong>：<br>	主函数运行时所创建，名字为<code>main</code><br>	在主函数中创建的线程为子线程<br>	二者可以交替运行，主线程的结束并不影响子线程的运行<br>通过实现Runnable接口创建线程</p>
<ul>
<li>之前所学继承Thread类来创建线程对于java的单继承机制有限制，如果有一个类已经继承了另外一个类便失效了</li>
<li>同样的重写run方法</li>
<li>Runnable没有<code>start</code>方法，要通过创建实现了Runnable的对象，将对象传入Thread类中(<strong>代理模式</strong>)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">//Runnable接口并没有start方法</span></span><br><span class="line">        <span class="comment">//通过借用Thread中的start达到启动线程的目的</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(dog);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hi&quot;</span>+(++num));</span><br><span class="line">            <span class="keyword">if</span>(num==<span class="number">10</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h5><p>线程完成任务之后会自动退出<br>通过方法停止线程<br>	设置控制变量，在主线程去控制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadExit_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//手动退出线程，本质上是结束run方法</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">//主线程沉睡6秒，然后终止子线程</span></span><br><span class="line">        Thread.sleep(<span class="number">6</span>*<span class="number">1000</span>);</span><br><span class="line">        t.setLoop(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> loop=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoop</span><span class="params">(<span class="type">boolean</span> loop)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">        <span class="keyword">while</span>(loop)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span>+(++count)+<span class="string">&quot;运行&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程常用方法<br>sleep：线程休眠<br>线程优先级范围<br>strat底层创建新线程<br><strong>interrupt中断线程，一般用于中断正在休眠的线程</strong></p>
<h5 id="线程插队-礼让"><a href="#线程插队-礼让" class="headerlink" title="线程插队&#x2F;礼让"></a>线程插队&#x2F;礼让</h5><p>yield: 礼让，主动让出cpu，但礼让的时间不确定，由cpu决定——静态方法<code>Thread.yield()</code><br>join：让别人插队，是在被插的线程中调用，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMethod02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//线程插队与礼让</span></span><br><span class="line">        <span class="type">T2</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T2</span>();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">//主线程也开始吃包子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">20</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程吃包子&quot;</span>+i);</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            <span class="comment">//吃了5个之后让子线程插队，待其全部吃完再返回主线程</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;让给子线程先执行&quot;</span>);</span><br><span class="line">                <span class="comment">//t2.join();</span></span><br><span class="line">                <span class="comment">//礼让，可能分配失败   注意是Thread.方法名</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.run();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程吃包子&quot;</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先启动线程再插队，顺序反了则插队无效</li>
</ul>
<h5 id="守护线程和用户线程"><a href="#守护线程和用户线程" class="headerlink" title="守护线程和用户线程"></a>守护线程和用户线程</h5><p>把线程设置成守护线程——只要主线程结束了，这个线程也要结束</p>
<ul>
<li>当所有的线程结束，守护线程也会结束</li>
<li>在线程开始之前就要设置成守护线程</li>
</ul>
<h5 id="生命周期和线程的七种状态"><a href="#生命周期和线程的七种状态" class="headerlink" title="生命周期和线程的七种状态"></a>生命周期和线程的七种状态</h5><ol>
<li>new：刚开始创建线程，此时，线程对象已经存在，但是线程还没有开始运行，也没有占用任何系统资源</li>
<li>Runable(可运行)：调用<code>Thread.start()</code>在可运行状态中，线程已经被线程调度器（Thread Scheduler）认定为可以被执行，但不一定马上执行，实际运行取决于操作系统的线程调度。</li>
<li>TimeWaiting：睡眠，</li>
<li>Waiting：被插队的线程会进入这个状态</li>
<li>Blocked：阻塞，等待别的进程归还同步锁时，会归还此状态</li>
<li>Terminated：线程终止，运行完毕</li>
</ol>
<h5 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h5><ul>
<li>在多线程编程中，一些敏感数据不允许别多个线程同时访问，同步技术保证数据在任意时刻，最多有一个线程访问，以此保护数据的完整性</li>
<li>使用<code>Synchr</code><br>同步代码块</li>
</ul>
<h4 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h4><p>创建文件的三种方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String：绝对地址  </span></span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create01</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\86135\\Desktop\\news.txt&quot;</span>;  </span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            file.createNewFile();  </span><br><span class="line">            System.out.println(<span class="string">&quot;创建成功&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">//  File+String：父目录文件对象+子文件名  </span></span><br><span class="line">    <span class="meta">@Test</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create02</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="type">File</span> <span class="variable">parentfile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\86135\\Desktop&quot;</span>);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;news.txt&quot;</span>;  </span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentfile,filename);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            file.createNewFile();  </span><br><span class="line">            System.out.println(<span class="string">&quot;创建成功&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">// String+String:父目录名+子文件名  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create03</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">parentfile</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\86135\\Desktop&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;news.txt&quot;</span>;  </span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentfile,filename);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            file.createNewFile();  </span><br><span class="line">            System.out.println(<span class="string">&quot;创建成功&quot;</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>文件路径名的两种写法<code>\\</code>或者<code>/</code></li>
<li>创建文件对象只是暂时保存在内存中，<code>createNewFile</code>才是将其写在硬盘上</li>
</ol>
<p><strong>查看文件相关信息</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\test01.txt&quot;</span>);</span><br><span class="line">    System.out.println(file.getAbsolutePath());    <span class="comment">//获取绝对路径</span></span><br><span class="line">    System.out.println(file.length());    <span class="comment">//获取文件内容字节数</span></span><br><span class="line">    System.out.println(file.isFile());    <span class="comment">//判断是否是文件</span></span><br><span class="line">    System.out.println(file.isDirectory());   <span class="comment">//判断是否是目录</span></span><br><span class="line">    System.out.println(file.exists());     <span class="comment">//判断文件是否存在</span></span><br><span class="line">    System.out.println(file.getParent());   <span class="comment">//获取父路径</span></span><br><span class="line">    System.out.println(file.getName());     <span class="comment">//获取文件名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>文件常用操作</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建多级目录   注意：`mkdir`是创建单层目录，`mkdirs`是创建多级目录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//判断多层目录是否存在，不存在则创建</span></span><br><span class="line">        String fileDictory=<span class="string">&quot;d:\\demo\\a\\b\\c&quot;</span>;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(fileDictory);</span><br><span class="line">        <span class="keyword">if</span>(file.exists())&#123;        <span class="comment">//先判断再创建</span></span><br><span class="line">            System.out.println(fileDictory+<span class="string">&quot;已存在&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.mkdirs())&#123;</span><br><span class="line">                System.out.println(fileDictory+<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(fileDictory+<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="IO流原理"><a href="#IO流原理" class="headerlink" title="IO流原理"></a>IO流原理</h5><ol>
<li>文件流分为字节流(8 bit, <strong>二进制文件无损</strong>)和字符流，字节流以字节为传输单位，适用于二进制文件，字符流以字符为单位，根据不同的编码方式字符单位的大小也不同，适用于文件传输</li>
<li>输出方向上分为输入流和输出流，输入流指由文件-&gt;控制台输出，输出流指由控制台-&gt;文件</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
<tr>
<td>上面这四个类衍生出一系列类，它们是最根本的，但它们都是<strong>抽象类</strong>，需要其子类来实现其方法</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\86135\\Desktop\\news.txt&quot;</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);  </span><br><span class="line">        <span class="keyword">while</span> ((readData = fis.read()) != -<span class="number">1</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            System.out.print((<span class="type">char</span>)readData);  <span class="comment">// 转成char显示  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            fis.close();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>字符流：</strong>(文本文件)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  字符输入流FileReader</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readf1</span><span class="params">()</span>&#123;</span><br><span class="line">        FileReader fileReader=<span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> data=<span class="number">0</span>;</span><br><span class="line">        String path=<span class="string">&quot;D:\\story.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileReader=<span class="keyword">new</span> <span class="title class_">FileReader</span>(path);</span><br><span class="line">            <span class="comment">//一次读取单个字符</span></span><br><span class="line">            <span class="comment">//read读到空值时会返回-1，否则对应每个字节会返回一个数字</span></span><br><span class="line">            <span class="keyword">while</span>((data=fileReader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>)data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//利用数组，一次读取多个字符,这种方法更快</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readf2</span><span class="params">()</span>&#123;</span><br><span class="line">        FileReader fileReader=<span class="literal">null</span>;</span><br><span class="line">        <span class="type">char</span>[] data=<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8</span>];</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        String path=<span class="string">&quot;D:\\story.txt&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fileReader=<span class="keyword">new</span> <span class="title class_">FileReader</span>(path);</span><br><span class="line">            <span class="comment">//一次读取单个字符</span></span><br><span class="line">            <span class="keyword">while</span>((len=fileReader.read(data))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符输入流  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">        FileWriter fileWriter=<span class="literal">null</span>;</span><br><span class="line">        String path=<span class="string">&quot;d:\\note.txt&quot;</span>;</span><br><span class="line">        <span class="type">char</span>[] data=&#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;j&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过设置true变为追加模式</span></span><br><span class="line">            fileWriter=<span class="keyword">new</span> <span class="title class_">FileWriter</span>(path,<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//fileWriter.write(1);</span></span><br><span class="line">            fileWriter.write(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">            fileWriter.write(<span class="string">&quot;哈哈哈哈&quot;</span>);</span><br><span class="line">            fileWriter.write(<span class="string">&quot;你好解耦&quot;</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">            fileWriter.write(data,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//必须要将写入流关闭，才能将数据成功写入，否则就是空文件</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fileWriter.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h4><p>节点流：直接连接数据源，执行基础的读写操作<br>处理流：封装了节点流，能够叠加在节点流之上，拓展流的功能(缓冲，数据类型转换)</p>
<h5 id="BufferReader-和-BufferWriter-——字符处理流"><a href="#BufferReader-和-BufferWriter-——字符处理流" class="headerlink" title="BufferReader 和 BufferWriter   ——字符处理流"></a>BufferReader 和 BufferWriter   ——字符处理流</h5><p>字符处理流<br><strong>BufferReader</strong>：<br>实体化时包装类<strong>Reader</strong>类，根据实际需要可以接收Reader的子类，也就实现了对不同文件的类型的操作<br>![[Pasted image 20241025203815.png]]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferReader01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String filepath=<span class="string">&quot;d:\\story.txt&quot;</span>;</span><br><span class="line">        BufferedReader bufferedReader=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filepath));  <span class="comment">// 传入Reader子类</span></span><br><span class="line">            String line=<span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//readline,一次读一行，返回字符串，读结束返回Null</span></span><br><span class="line">            <span class="keyword">while</span>((line=bufferedReader.readLine())!=<span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭外层，即关闭BufferReader即可</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bufferedReader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferWriter01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        String path=<span class="string">&quot;d:\\ok.txt&quot;</span>;</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(path,<span class="literal">true</span>));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;syx&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();</span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BufferedInputStream和BufferedOutputStream-——-字节处理流"><a href="#BufferedInputStream和BufferedOutputStream-——-字节处理流" class="headerlink" title="BufferedInputStream和BufferedOutputStream —— 字节处理流"></a>BufferedInputStream和BufferedOutputStream —— 字节处理流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferCopy02</span> &#123; \\ 复制就是读入后 写出</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        String srcpath=<span class="string">&quot;D:\\JUST\\研1\\分享资料\\bhg.png&quot;</span>;</span><br><span class="line">        String despath=<span class="string">&quot;D:\\bhg.png&quot;</span>;</span><br><span class="line">        <span class="comment">//利用字节数组进行存储</span></span><br><span class="line">        <span class="type">byte</span>[] data=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcpath));</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(despath));</span><br><span class="line">        <span class="keyword">while</span>((len=bufferedInputStream.read(data))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            bufferedOutputStream.write(data,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ObjectOutputStream和ObjectInputStream-——-对象处理流"><a href="#ObjectOutputStream和ObjectInputStream-——-对象处理流" class="headerlink" title="ObjectOutputStream和ObjectInputStream —— 对象处理流"></a>ObjectOutputStream和ObjectInputStream —— 对象处理流</h5><ul>
<li>存储数据时，一般的存储只存储了数据，要将文件进行如恢复的操作还需要知道对应的数据类型，这种将数据及其类型进行存储的方式叫做序列化，反之称为反序列化。</li>
<li>也就出现了将数据进行对象形式传输的方法，根据输入和输出分为ObjectOutputStream和ObjectInputStream</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectOutputStream_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String path=<span class="string">&quot;d:\\data.dat&quot;</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path));</span><br><span class="line">        objectOutputStream.writeInt(<span class="number">1</span>);</span><br><span class="line">        objectOutputStream.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">        objectOutputStream.writeDouble(<span class="number">0.9</span>);</span><br><span class="line">        objectOutputStream.writeUTF(<span class="string">&quot;hello&quot;</span>);    <span class="comment">//存储String类型用writeUTF</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//以上几个都是实现了Serializable的类，存储时会自动装箱</span></span><br><span class="line">        <span class="comment">//必须是实现了Serializable接口的类才能进行序列化操作</span></span><br><span class="line">        objectOutputStream.writeObject(<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">10</span>,<span class="string">&quot;hxy&quot;</span>,<span class="string">&quot;白色&quot;</span>,<span class="number">2</span>));</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其中的自定义Dog类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> serialVersionUID=<span class="number">1</span>;   <span class="comment">//版本控制，当该类出现修改时，无需重新序列化和反序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> add;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> age, String name,String color,<span class="type">int</span> add)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.color=color;</span><br><span class="line">        <span class="built_in">this</span>.add=add;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>+color+add;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;goujiao&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ObjectInputStream </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjectInputStream_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String path=<span class="string">&quot;d:\\data.dat&quot;</span>;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path));</span><br><span class="line">        <span class="comment">//要符合序列化时的输入顺序</span></span><br><span class="line">        System.out.println(objectInputStream.readInt());</span><br><span class="line">        System.out.println(objectInputStream.readBoolean());</span><br><span class="line">        System.out.println(objectInputStream.readDouble());</span><br><span class="line">        System.out.println(objectInputStream.readUTF());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">        System.out.println(object.getClass());</span><br><span class="line">        System.out.println(object);</span><br><span class="line">        Dog dog=(Dog)object;  <span class="comment">//向下转型</span></span><br><span class="line">        dog.shout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<ul>
<li>序列化的前提是这个数据类型或者类实现了<code>Serializable</code>这个接口，即可序列化</li>
<li>读取文件中的序列化数据(反序列化)要按照序列化的顺序进行反序列化</li>
<li>带有<code>terminant</code>和<code>static</code>修饰的属性是不会进入序列化的</li>
<li>若自定义类中有所改动，则反序列化会失败，要重新序列化才可以。另外一个办法是在自定义类中加上<code>private final long seriaVersionUID</code>这个属性，表示版本号</li>
</ul>
<h5 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h5><p>System.out 是输出流，编译和运行类型都是PrintStream<br>System.in 是输入流，编译类型是InputStream，运行类型是BufferedInputStream</p>
<h5 id="字节流-字符流-转换流"><a href="#字节流-字符流-转换流" class="headerlink" title="字节流 -&gt; 字符流      转换流"></a>字节流 -&gt; 字符流      转换流</h5><p>文件存在编码问题需要进行转换</p>
<ul>
<li><strong>输入转换InputStreamReader</strong><ul>
<li>将字节流转换成字符流</li>
<li>![[Pasted image 20241028153732.png]]</li>
<li>构造器第一个参数是inputstream类及其子类，第二个参数是编码类型<br>输出流类似<code>OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(path), &quot;utf8&quot;);</code></li>
</ul>
</li>
</ul>
<p>字节输出流PrintStream<br>System.out是输出到控制台的，可以通过设置输出的地址输出到不同的地方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//System类下的out是PrintStream类对象</span></span><br><span class="line">PrintStream out=System.out;</span><br><span class="line">out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//println底层调用的是write方法，因此这两个方法是一样的，只是输入参数类型不同</span></span><br><span class="line">out.write(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新设置输出路径</span></span><br><span class="line">System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;d:\\f1.txt&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;hellosyx&quot;</span>);</span><br><span class="line"><span class="type">PrintStream</span> <span class="variable">printStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;d:\\f2.txt&quot;</span>));</span><br><span class="line">printStream.println(<span class="string">&quot;hhhh&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>字符</strong>输出流PrintWriter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">printWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;d:\\f3.txt&quot;</span>));</span><br><span class="line">printWriter.println(<span class="string">&quot;字符输入流&quot;</span>);</span><br><span class="line">printWriter.close();  <span class="comment">//用完一定要关闭</span></span><br></pre></td></tr></table></figure>
<h5 id="配置文件-Properties"><a href="#配置文件-Properties" class="headerlink" title="配置文件 Properties"></a><strong>配置文件</strong> Properties</h5><ul>
<li>Properties类操作的文件内容必须是有&#x3D;号的，即“键”&#x3D;“值”  等号两边没有空格<br>读取文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.实体化类对象</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//2.将内容载入对象中</span></span><br><span class="line">properties.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src//mysql.properties&quot;</span>));</span><br><span class="line"><span class="comment">//3.选择将内容输出到控制台上</span></span><br><span class="line">properties.list(System.out);</span><br><span class="line"><span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure>
<p>修改存储文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.setProperty(<span class="string">&quot;add&quot;</span>,<span class="string">&quot;wanke&quot;</span>);</span><br><span class="line">properties.setProperty(<span class="string">&quot;phone&quot;</span>,<span class="string">&quot;11234&quot;</span>);  <span class="comment">// 修改的键不存在就增加</span></span><br><span class="line">properties.store(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;src\\mysql02.properties&quot;</span>),<span class="literal">null</span>);  <span class="comment">// 第二个参数是备注信息</span></span><br></pre></td></tr></table></figure>


<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><p>在网络开发中不要使用0-1024的端口<br>域名：<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>    dns   IP映射成域名，域名好记<br>协议就是网络编程中数据组织的形式，如josh数据？</p>
<h4 id="Socket-数据连接"><a href="#Socket-数据连接" class="headerlink" title="Socket 数据连接"></a>Socket 数据连接</h4><h4 id="TCP-字节流"><a href="#TCP-字节流" class="headerlink" title="TCP 字节流"></a>TCP 字节流</h4><p><strong>服务端：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="comment">//1.在本地创建指定接口进行监听</span></span><br><span class="line"><span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待9999端口的消息传送...&quot;</span>);</span><br><span class="line"><span class="comment">//接收来自客户端的消息,这里如果没有消息传送过来，则会阻塞一直等待连接</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">System.out.println(accept.getClass());</span><br><span class="line"><span class="comment">//进行消息的接收，传输到控制台上</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line"><span class="comment">//接下来就是io方面的内容</span></span><br><span class="line"><span class="type">byte</span>[] data=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> line=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((line=inputStream.read(data))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,line));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给客户端回消息</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> accept.getOutputStream();</span><br><span class="line">outputStream.write(<span class="string">&quot;hello,client&quot;</span>.getBytes());</span><br><span class="line">accept.shutdownOutput();</span><br><span class="line"><span class="comment">//关闭接口</span></span><br><span class="line">outputStream.close();</span><br><span class="line">inputStream.close();</span><br><span class="line">serverSocket.close();</span><br><span class="line">System.out.println(<span class="string">&quot;服务端已关闭&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>服务端使用SeverSocket类在端监听，若有连接通过serverSocket.accept()方法得到Socket类并建立会话关系，Socket类进行数据的获取<br><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端 与服务端进行交互</span></span><br><span class="line"><span class="comment">//连接本服务器的指定端口 ip+端口</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line"><span class="comment">//获取输出流。将数据输出到数据通道</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">outputStream.write(<span class="string">&quot;hello.server&quot;</span>.getBytes());</span><br><span class="line"><span class="comment">//设置写入结束标记</span></span><br><span class="line">socket.shutdownOutput();</span><br><span class="line"><span class="comment">//获取来自服务端的回复</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line"><span class="type">byte</span>[] data=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> line=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((line=inputStream.read(data))!=-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,line));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭流及socket</span></span><br><span class="line">inputStream.close();</span><br><span class="line">outputStream.close();</span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>
<p>需注意，两端并不知道对方何时数据传输结束，需在自己方设置<code>socket.shutdownOutput();</code>表示写入结束。否则在第一段通话结束后，陷入等待</p>
<h4 id="TCP-字符流"><a href="#TCP-字符流" class="headerlink" title="TCP 字符流"></a>TCP 字符流</h4><p>字符流传输就是在昨天的字节流传输的基础上，进行字节流-&gt;字符流的转换操作<br><strong>服务端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line">        <span class="comment">//1.在本地创建指定接口进行监听</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待9999端口的消息传送...&quot;</span>);</span><br><span class="line">        <span class="comment">//接收来自客户端的消息,这里如果没有消息传送过来，则会阻塞一直等待连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        System.out.println(accept.getClass());</span><br><span class="line">        <span class="comment">//进行消息的接收，传输到控制台上</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> accept.getInputStream();</span><br><span class="line">        String data=<span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//字节流转字符流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        data=bufferedReader.readLine();</span><br><span class="line">        System.out.println(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//给客户端回消息</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> accept.getOutputStream();</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello,client&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();   <span class="comment">//字符流中，换行就表示当前输出结束，和字节流的shutdown同理</span></span><br><span class="line">        bufferedWriter.flush();    <span class="comment">//进行此步才会将数据写入通道</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭接口</span></span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端已关闭&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端 与服务端进行交互</span></span><br><span class="line">        <span class="comment">//连接本服务器的指定端口 ip+端口</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">9999</span>);</span><br><span class="line">        <span class="comment">//获取输出流。将数据输出到数据通道 字节流-&gt;字符流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream));</span><br><span class="line">        bufferedWriter.write(<span class="string">&quot;hello,server&quot;</span>);</span><br><span class="line">        bufferedWriter.newLine();   <span class="comment">//字符流中，换行就表示当前输出结束，和字节流的shutdown同理</span></span><br><span class="line">        bufferedWriter.flush();    <span class="comment">//进行此步才会将数据写入通道</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取来自服务端的回复</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">        String data=<span class="literal">null</span>;</span><br><span class="line">        data=bufferedReader.readLine();</span><br><span class="line">        System.out.println(data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流及socket</span></span><br><span class="line">        bufferedWriter.close();</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">        socket.close();</span><br></pre></td></tr></table></figure>
<p>注意:<br>在字符流中用<code>newline()</code>表示当前输出结束<br>输出结束后要用<code>flush()</code>方法才能成功输出内容<br>接受的一方要用<code>readline()</code>来读出内容</p>
<h3 id="TCP图像传输"><a href="#TCP图像传输" class="headerlink" title="TCP图像传输"></a>TCP图像传输</h3><p>首先知道图像是一个二进制文件，所以用字节流</p>
<ol>
<li>新建输入流根据具体路径获得文件数据，存储在字节数组中</li>
<li>在客户端新建Socket的输出流，将文件输出</li>
<li>服务端接收，获取Socket的输入流，获取文件的字节数组</li>
<li>服务器新建输出流，将获取的字节数组转化为文件存储到指定路径<br><strong>服务端</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置8888为服务端端口号</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//等到客户端连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();</span><br><span class="line">        <span class="comment">//读取图片的字节信息</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] bytes = StreamUtils.streamToByteArray(inputStream);</span><br><span class="line">        <span class="comment">//将字节信息转化为图片放在本地的src目录下</span></span><br><span class="line">        String path=<span class="string">&quot;src\\bg.png&quot;</span>;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(path));</span><br><span class="line">        bufferedOutputStream.write(bytes);</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br></pre></td></tr></table></figure>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLocalHost(), <span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//进行图形信息的读取</span></span><br><span class="line">        String path=<span class="string">&quot;d:\\bhg.png&quot;</span>;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bufferedInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path));</span><br><span class="line">        <span class="comment">//借用已写好的工具包，获取图片的字节数组形式</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = StreamUtils.streamToByteArray(bufferedInputStream);</span><br><span class="line">        <span class="comment">//将数组通过通道传递给客户端</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bufferedOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(outputStream);</span><br><span class="line">        bufferedOutputStream.write(bytes);</span><br><span class="line">        <span class="comment">//表示当前输入结束</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        bufferedOutputStream.close();</span><br><span class="line">        bufferedInputStream.close();</span><br><span class="line">        socket.close();</span><br></pre></td></tr></table></figure>

<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>动态加载和静态加载<br>静态加载：在编译的时候就检查<br><strong>动态加载：没用到就不会报错</strong><br>反射是动态加载，原始方法 new 类是静态加载</p>
<p><strong>类加载三个阶段</strong>：加载  连接  初始化(静态变量初始化)<br>连接阶段：验证-准备-解析<br>验证安全性    解析：把符号引用变成真正的地址引用</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">集中一点</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/12/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/">http://example.com/2024/12/08/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="post-share"><div class="social-share" data-image="/img/icon1point.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/" title="多线程入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">多线程入门</div></div><div class="info-2"><div class="info-item-1">从现在开始，我们进入并发编程的学习，那么首先我们要了解的就是多线程。  Java单线程程序已经能够完成逻辑处理，为什么还需要“多线程”呢？  单线程只能同时做一件事，无法同时进行多个任务。如果某个操作耗时较长，会引起主线程的阻塞，导致程序变慢。 单线程像是你在同一时间只能写作业，而有些人却能够边听歌，看综艺，还能写作业。 进程与线程？在操作系统中，我们常听到“进程”和“线程”这两个词，它们到底是什么？两者有什么区别？为什么需要多线程而不是直接使用多个进程？    概念 定义    进程 操作系统资源分配的基本单位。每个运行中的程序就是一个进程，拥有独立的内存空间和系统资源。   线程 进程中执行的最小单元，是CPU调度的基本单位。一个进程中可以包含多个线程，它们共享进程的资源。   简单来说，每个程序就是一个进程，一个进程可以拥有多个线程 Java 中创建多线程的常见方式继承Thread类 12345678class MyThread extends Thread &#123;    @Override    public void run() &#123;        Sys...</div></div></div></a><a class="pagination-related" href="/2024/08/22/%E6%9A%91%E5%81%87%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%83%B3/" title="暑假学习感想"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">暑假学习感想</div></div><div class="info-2"><div class="info-item-1">先介绍一下自身的情况，虽然是在一个双非学校就读数学系，但在这之前我已经修了专业课C语言，C++，python，数据结构了在去年寒假准备算法竞赛学了一些基础算法和数据结构，但比赛拉胯之后道心破碎了（我只是会背一些基础板子，唉，赛前做了一些dfs，bfs自我感觉还不错的），所以本学期的数据结构没听，后面三天速通88分，纯粹的背题考试机器罢了。在暑期到来之前，也是在我考完专业课后十天左右的假期的时候，在b站刷到了upjiangxiangchi的计算机学习路线这一视频，好像不能算是刷，我自己找的，因为马上就大三了，在一个双非学校且因为经济原因放弃考研的我突然意识到毕业即失业的我决定转码。虽然我7月5日就放假了，但我实实在在的假期却是7月20号开始的，中间被那个三下乡志愿折磨的劳心劳力。 中途折腾了个博客，就是你现在看到的这个，挺好玩的哈哈哈哈。看了《程序是怎样运行的》，前面九章我看得懂，大概对计组有了一点了解，后面三章我的知识就匮乏了··· 正文版本是最新的24summer，视频是b站21spring精译版因为之前学习过python，所以前面的学习并没有很困难，直到递归，这玩意在我之前学...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/icon1point.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">集中一点</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">一起加油！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">枚举和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.1.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.2.</span> <span class="toc-text">注解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">3.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">4.</span> <span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">常用类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Wrapper"><span class="toc-number">6.</span> <span class="toc-text">Wrapper</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB-1"><span class="toc-number">7.</span> <span class="toc-text">常用类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">8.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E5%9B%BE%E3%80%90%E8%83%8C%EF%BC%81%EF%BC%81%EF%BC%81%E3%80%91"><span class="toc-number">8.1.</span> <span class="toc-text">集合体系图【背！！！】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.2.</span> <span class="toc-text">Collection接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.3.</span> <span class="toc-text">List接口</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ArrayList%E5%92%8CVector%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">8.3.1.</span> <span class="toc-text">ArrayList和Vector的比较</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#LinkedList%E7%B1%BB"><span class="toc-number">8.4.</span> <span class="toc-text">LinkedList类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#LinkedList%E5%92%8CArrayList%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">8.4.1.</span> <span class="toc-text">LinkedList和ArrayList的比较</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Set%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.5.</span> <span class="toc-text">Set接口</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#HashSet"><span class="toc-number">8.5.1.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#LinkHashSet"><span class="toc-number">8.5.2.</span> <span class="toc-text">LinkHashSet</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3%EF%BC%88JDK8%EF%BC%89"><span class="toc-number">8.6.</span> <span class="toc-text">Map接口（JDK8）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Map%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.6.1.</span> <span class="toc-text">Map常用方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Map%E5%85%AD%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">8.6.2.</span> <span class="toc-text">Map六种遍历方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#HashMap%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="toc-number">8.6.3.</span> <span class="toc-text">HashMap底层机制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#HashTable%E5%AF%B9%E6%AF%94HashMap"><span class="toc-number">8.6.4.</span> <span class="toc-text">HashTable对比HashMap</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">8.7.</span> <span class="toc-text">Collections工具类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%B0%8F%E7%BB%93"><span class="toc-number">8.8.</span> <span class="toc-text">集合小结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">9.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-number">9.1.</span> <span class="toc-text">细节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-number">9.2.</span> <span class="toc-text">自定义泛型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">9.3.</span> <span class="toc-text">事件处理机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">10.1.</span> <span class="toc-text">线程终止</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%8F%92%E9%98%9F-%E7%A4%BC%E8%AE%A9"><span class="toc-number">10.2.</span> <span class="toc-text">线程插队&#x2F;礼让</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.3.</span> <span class="toc-text">守护线程和用户线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%83%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">10.4.</span> <span class="toc-text">生命周期和线程的七种状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">10.5.</span> <span class="toc-text">线程同步机制</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">11.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#IO%E6%B5%81%E5%8E%9F%E7%90%86"><span class="toc-number">11.1.</span> <span class="toc-text">IO流原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">12.</span> <span class="toc-text">节点流和处理流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BufferReader-%E5%92%8C-BufferWriter-%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">12.1.</span> <span class="toc-text">BufferReader 和 BufferWriter   ——字符处理流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BufferedInputStream%E5%92%8CBufferedOutputStream-%E2%80%94%E2%80%94-%E5%AD%97%E8%8A%82%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">12.2.</span> <span class="toc-text">BufferedInputStream和BufferedOutputStream —— 字节处理流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ObjectOutputStream%E5%92%8CObjectInputStream-%E2%80%94%E2%80%94-%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">12.3.</span> <span class="toc-text">ObjectOutputStream和ObjectInputStream —— 对象处理流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">12.4.</span> <span class="toc-text">标准输入输出流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81-%E5%AD%97%E7%AC%A6%E6%B5%81-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">12.5.</span> <span class="toc-text">字节流 -&gt; 字符流      转换流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-Properties"><span class="toc-number">12.6.</span> <span class="toc-text">配置文件 Properties</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket-%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.</span> <span class="toc-text">Socket 数据连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">2.</span> <span class="toc-text">TCP 字节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">3.</span> <span class="toc-text">TCP 字符流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%9B%BE%E5%83%8F%E4%BC%A0%E8%BE%93"><span class="toc-number"></span> <span class="toc-text">TCP图像传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number"></span> <span class="toc-text">反射</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/06/hello-world/" title="Hello">Hello</a><time datetime="2025-08-06T10:19:07.236Z" title="Created 2025-08-06 18:19:07">2025-08-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/08/volatile%E5%92%8Csynchronize/" title="volatile和synchronize">volatile和synchronize</a><time datetime="2025-04-08T15:12:22.000Z" title="Created 2025-04-08 23:12:22">2025-04-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/04/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8CExecutor%E6%A1%86%E6%9E%B6/" title="线程池和Executor框架">线程池和Executor框架</a><time datetime="2025-03-31T16:00:00.000Z" title="Created 2025-04-01 00:00:00">2025-04-01</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2023 - 2025 By 集中一点</span></div><div class="footer_custom_text">Coding，Feeling，Doing！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>